{"ast":null,"code":"// Returns all nodes in the order in which they were visited.\n// Also sets previousNode for shortest path backtracking.\n\nexport function bellmanFord(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  const allNodes = getAllNodes(grid);\n\n  // Step 1: Initialize distances\n  for (const node of allNodes) {\n    node.distance = Infinity;\n    node.previousNode = null;\n  }\n  startNode.distance = 0;\n  const totalNodes = allNodes.length;\n\n  // Step 2: Relax all edges (V - 1) times\n  for (let i = 0; i < totalNodes - 1; i++) {\n    for (const row of grid) {\n      for (const node of row) {\n        if (node.isWall) continue;\n        const neighbors = getUnvisitedNeighbors(node, grid);\n        for (const neighbor of neighbors) {\n          if (neighbor.isWall) continue;\n          const newDist = node.distance + 1; // You can use weights here if needed\n          if (newDist < neighbor.distance) {\n            neighbor.distance = newDist;\n            neighbor.previousNode = node;\n          }\n        }\n      }\n    }\n  }\n\n  // Step 3: Build visitedNodesInOrder like Dijkstra\n  for (const row of grid) {\n    for (const node of row) {\n      if (node.distance !== Infinity && !node.isWall) {\n        node.isVisited = true;\n        visitedNodesInOrder.push(node);\n        if (node === finishNode) return visitedNodesInOrder;\n      }\n    }\n  }\n  return visitedNodesInOrder;\n}","map":{"version":3,"names":["bellmanFord","grid","startNode","finishNode","visitedNodesInOrder","allNodes","getAllNodes","node","distance","Infinity","previousNode","totalNodes","length","i","row","isWall","neighbors","getUnvisitedNeighbors","neighbor","newDist","isVisited","push"],"sources":["C:/Users/TARUN/Downloads/pathFinderVisualizer-master/pathFinderVisualizer-master/src/algorithms/dijkstra.js"],"sourcesContent":["// Returns all nodes in the order in which they were visited.\r\n// Also sets previousNode for shortest path backtracking.\r\n\r\nexport function bellmanFord(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  const allNodes = getAllNodes(grid);\r\n\r\n  // Step 1: Initialize distances\r\n  for (const node of allNodes) {\r\n    node.distance = Infinity;\r\n    node.previousNode = null;\r\n  }\r\n  startNode.distance = 0;\r\n\r\n  const totalNodes = allNodes.length;\r\n\r\n  // Step 2: Relax all edges (V - 1) times\r\n  for (let i = 0; i < totalNodes - 1; i++) {\r\n    for (const row of grid) {\r\n      for (const node of row) {\r\n        if (node.isWall) continue;\r\n\r\n        const neighbors = getUnvisitedNeighbors(node, grid);\r\n        for (const neighbor of neighbors) {\r\n          if (neighbor.isWall) continue;\r\n\r\n          const newDist = node.distance + 1; // You can use weights here if needed\r\n          if (newDist < neighbor.distance) {\r\n            neighbor.distance = newDist;\r\n            neighbor.previousNode = node;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Step 3: Build visitedNodesInOrder like Dijkstra\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      if (node.distance !== Infinity && !node.isWall) {\r\n        node.isVisited = true;\r\n        visitedNodesInOrder.push(node);\r\n        if (node === finishNode) return visitedNodesInOrder;\r\n      }\r\n    }\r\n  }\r\n\r\n  return visitedNodesInOrder;\r\n}\r\n"],"mappings":"AAAA;AACA;;AAEA,OAAO,SAASA,WAAWA,CAACC,IAAI,EAAEC,SAAS,EAAEC,UAAU,EAAE;EACvD,MAAMC,mBAAmB,GAAG,EAAE;EAC9B,MAAMC,QAAQ,GAAGC,WAAW,CAACL,IAAI,CAAC;;EAElC;EACA,KAAK,MAAMM,IAAI,IAAIF,QAAQ,EAAE;IAC3BE,IAAI,CAACC,QAAQ,GAAGC,QAAQ;IACxBF,IAAI,CAACG,YAAY,GAAG,IAAI;EAC1B;EACAR,SAAS,CAACM,QAAQ,GAAG,CAAC;EAEtB,MAAMG,UAAU,GAAGN,QAAQ,CAACO,MAAM;;EAElC;EACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,UAAU,GAAG,CAAC,EAAEE,CAAC,EAAE,EAAE;IACvC,KAAK,MAAMC,GAAG,IAAIb,IAAI,EAAE;MACtB,KAAK,MAAMM,IAAI,IAAIO,GAAG,EAAE;QACtB,IAAIP,IAAI,CAACQ,MAAM,EAAE;QAEjB,MAAMC,SAAS,GAAGC,qBAAqB,CAACV,IAAI,EAAEN,IAAI,CAAC;QACnD,KAAK,MAAMiB,QAAQ,IAAIF,SAAS,EAAE;UAChC,IAAIE,QAAQ,CAACH,MAAM,EAAE;UAErB,MAAMI,OAAO,GAAGZ,IAAI,CAACC,QAAQ,GAAG,CAAC,CAAC,CAAC;UACnC,IAAIW,OAAO,GAAGD,QAAQ,CAACV,QAAQ,EAAE;YAC/BU,QAAQ,CAACV,QAAQ,GAAGW,OAAO;YAC3BD,QAAQ,CAACR,YAAY,GAAGH,IAAI;UAC9B;QACF;MACF;IACF;EACF;;EAEA;EACA,KAAK,MAAMO,GAAG,IAAIb,IAAI,EAAE;IACtB,KAAK,MAAMM,IAAI,IAAIO,GAAG,EAAE;MACtB,IAAIP,IAAI,CAACC,QAAQ,KAAKC,QAAQ,IAAI,CAACF,IAAI,CAACQ,MAAM,EAAE;QAC9CR,IAAI,CAACa,SAAS,GAAG,IAAI;QACrBhB,mBAAmB,CAACiB,IAAI,CAACd,IAAI,CAAC;QAC9B,IAAIA,IAAI,KAAKJ,UAAU,EAAE,OAAOC,mBAAmB;MACrD;IACF;EACF;EAEA,OAAOA,mBAAmB;AAC5B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}