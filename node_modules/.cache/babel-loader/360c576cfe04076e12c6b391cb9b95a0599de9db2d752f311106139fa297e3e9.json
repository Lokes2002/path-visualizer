{"ast":null,"code":"// bfs.js\nexport function bfs(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  let queue = [startNode];\n  while (queue.length) {\n    const currentNode = queue.shift();\n    if (currentNode === finishNode) return visitedNodesInOrder;\n    if (!currentNode.isWall && !currentNode.isVisited) {\n      currentNode.isVisited = true;\n      visitedNodesInOrder.push(currentNode);\n      const {\n        row,\n        col\n      } = currentNode;\n      const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n      for (const [dx, dy] of directions) {\n        const newRow = row + dx;\n        const newCol = col + dy;\n        if (newRow >= 0 && newRow < grid.length && newCol >= 0 && newCol < grid[0].length) {\n          const neighbor = grid[newRow][newCol];\n          if (!neighbor.isVisited) {\n            neighbor.previousNode = currentNode;\n            queue.push(neighbor);\n          }\n        }\n      }\n    }\n  }\n  return visitedNodesInOrder;\n}","map":{"version":3,"names":["bfs","grid","startNode","finishNode","visitedNodesInOrder","queue","length","currentNode","shift","isWall","isVisited","push","row","col","directions","dx","dy","newRow","newCol","neighbor","previousNode"],"sources":["C:/Users/TARUN/Downloads/pathFinderVisualizer-master/pathFinderVisualizer-master/src/algorithms/bfs.js"],"sourcesContent":["// bfs.js\r\nexport function bfs(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  let queue = [startNode];\r\n  while (queue.length) {\r\n    const currentNode = queue.shift();\r\n    if (currentNode === finishNode) return visitedNodesInOrder;\r\n\r\n    if (!currentNode.isWall && !currentNode.isVisited) {\r\n      currentNode.isVisited = true;\r\n      visitedNodesInOrder.push(currentNode);\r\n      const {row, col} = currentNode;\r\n\r\n      const directions = [\r\n        [0, 1], [0, -1], [1, 0], [-1, 0]\r\n      ];\r\n      for (const [dx, dy] of directions) {\r\n        const newRow = row + dx;\r\n        const newCol = col + dy;\r\n        if (newRow >= 0 && newRow < grid.length && newCol >= 0 && newCol < grid[0].length) {\r\n          const neighbor = grid[newRow][newCol];\r\n          if (!neighbor.isVisited) {\r\n            neighbor.previousNode = currentNode;\r\n            queue.push(neighbor);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return visitedNodesInOrder;\r\n}\r\n"],"mappings":"AAAA;AACA,OAAO,SAASA,GAAGA,CAACC,IAAI,EAAEC,SAAS,EAAEC,UAAU,EAAE;EAC/C,MAAMC,mBAAmB,GAAG,EAAE;EAC9B,IAAIC,KAAK,GAAG,CAACH,SAAS,CAAC;EACvB,OAAOG,KAAK,CAACC,MAAM,EAAE;IACnB,MAAMC,WAAW,GAAGF,KAAK,CAACG,KAAK,CAAC,CAAC;IACjC,IAAID,WAAW,KAAKJ,UAAU,EAAE,OAAOC,mBAAmB;IAE1D,IAAI,CAACG,WAAW,CAACE,MAAM,IAAI,CAACF,WAAW,CAACG,SAAS,EAAE;MACjDH,WAAW,CAACG,SAAS,GAAG,IAAI;MAC5BN,mBAAmB,CAACO,IAAI,CAACJ,WAAW,CAAC;MACrC,MAAM;QAACK,GAAG;QAAEC;MAAG,CAAC,GAAGN,WAAW;MAE9B,MAAMO,UAAU,GAAG,CACjB,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CACjC;MACD,KAAK,MAAM,CAACC,EAAE,EAAEC,EAAE,CAAC,IAAIF,UAAU,EAAE;QACjC,MAAMG,MAAM,GAAGL,GAAG,GAAGG,EAAE;QACvB,MAAMG,MAAM,GAAGL,GAAG,GAAGG,EAAE;QACvB,IAAIC,MAAM,IAAI,CAAC,IAAIA,MAAM,GAAGhB,IAAI,CAACK,MAAM,IAAIY,MAAM,IAAI,CAAC,IAAIA,MAAM,GAAGjB,IAAI,CAAC,CAAC,CAAC,CAACK,MAAM,EAAE;UACjF,MAAMa,QAAQ,GAAGlB,IAAI,CAACgB,MAAM,CAAC,CAACC,MAAM,CAAC;UACrC,IAAI,CAACC,QAAQ,CAACT,SAAS,EAAE;YACvBS,QAAQ,CAACC,YAAY,GAAGb,WAAW;YACnCF,KAAK,CAACM,IAAI,CAACQ,QAAQ,CAAC;UACtB;QACF;MACF;IACF;EACF;EACA,OAAOf,mBAAmB;AAC5B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}