{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\TARUN\\\\Downloads\\\\pathFinderVisualizer-master\\\\pathFinderVisualizer-master\\\\src\\\\PathfindingVisualizer\\\\PathfindingVisualizer.jsx\";\nimport React, { Component } from 'react';\nimport Node from './Node/Node';\nimport { dijkstra } from '../algorithms/dijkstra';\nimport { AStar } from '../algorithms/aStar';\nimport { dfs } from '../algorithms/dfs';\nimport { bfs } from '../algorithms/bfs';\nimport './PathfindingVisualizer.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n    /******************** Set up the initial grid ********************/\n    this.getInitialGrid = (rowCount = this.state.ROW_COUNT, colCount = this.state.COLUMN_COUNT) => {\n      const initialGrid = [];\n      for (let row = 0; row < rowCount; row++) {\n        const currentRow = [];\n        for (let col = 0; col < colCount; col++) {\n          currentRow.push(this.createNode(row, col));\n        }\n        initialGrid.push(currentRow);\n      }\n      return initialGrid;\n    };\n    this.createNode = (row, col) => {\n      return {\n        row,\n        col,\n        isStart: row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL,\n        isFinish: row === this.state.FINISH_NODE_ROW && col === this.state.FINISH_NODE_COL,\n        distance: Infinity,\n        distanceToFinishNode: Math.abs(this.state.FINISH_NODE_ROW - row) + Math.abs(this.state.FINISH_NODE_COL - col),\n        isVisited: false,\n        isWall: false,\n        previousNode: null,\n        isNode: true\n      };\n    };\n    this.state = {\n      grid: [],\n      START_NODE_ROW: 3,\n      FINISH_NODE_ROW: 16,\n      START_NODE_COL: 5,\n      FINISH_NODE_COL: 25,\n      mouseIsPressed: false,\n      ROW_COUNT: 25,\n      COLUMN_COUNT: 35,\n      isRunning: false,\n      isStartNode: false,\n      isFinishNode: false,\n      isWallNode: false,\n      // xxxxxxx\n      currRow: 0,\n      currCol: 0\n    };\n    this.handleMouseDown = this.handleMouseDown.bind(this);\n    this.handleMouseLeave = this.handleMouseLeave.bind(this);\n    this.toggleIsRunning = this.toggleIsRunning.bind(this);\n  }\n  componentDidMount() {\n    const grid = this.getInitialGrid();\n    this.setState({\n      grid\n    });\n  }\n  toggleIsRunning() {\n    this.setState({\n      isRunning: !this.state.isRunning\n    });\n  }\n  /******************** Control mouse events ********************/\n  handleMouseDown(row, col) {\n    if (!this.state.isRunning) {\n      if (this.isGridClear()) {\n        if (document.getElementById(`node-${row}-${col}`).className === 'node node-start') {\n          this.setState({\n            mouseIsPressed: true,\n            isStartNode: true,\n            currRow: row,\n            currCol: col\n          });\n        } else if (document.getElementById(`node-${row}-${col}`).className === 'node node-finish') {\n          this.setState({\n            mouseIsPressed: true,\n            isFinishNode: true,\n            currRow: row,\n            currCol: col\n          });\n        } else {\n          const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n          this.setState({\n            grid: newGrid,\n            mouseIsPressed: true,\n            isWallNode: true,\n            currRow: row,\n            currCol: col\n          });\n        }\n      } else {\n        this.clearGrid();\n      }\n    }\n  }\n  isGridClear() {\n    for (const row of this.state.grid) {\n      for (const node of row) {\n        const nodeClassName = document.getElementById(`node-${node.row}-${node.col}`).className;\n        if (nodeClassName === 'node node-visited' || nodeClassName === 'node node-shortest-path') {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  handleMouseEnter(row, col) {\n    if (!this.state.isRunning) {\n      if (this.state.mouseIsPressed) {\n        const nodeClassName = document.getElementById(`node-${row}-${col}`).className;\n        if (this.state.isStartNode) {\n          if (nodeClassName !== 'node node-wall') {\n            const prevStartNode = this.state.grid[this.state.currRow][this.state.currCol];\n            prevStartNode.isStart = false;\n            document.getElementById(`node-${this.state.currRow}-${this.state.currCol}`).className = 'node';\n            this.setState({\n              currRow: row,\n              currCol: col\n            });\n            const currStartNode = this.state.grid[row][col];\n            currStartNode.isStart = true;\n            document.getElementById(`node-${row}-${col}`).className = 'node node-start';\n          }\n          this.setState({\n            START_NODE_ROW: row,\n            START_NODE_COL: col\n          });\n        } else if (this.state.isFinishNode) {\n          if (nodeClassName !== 'node node-wall') {\n            const prevFinishNode = this.state.grid[this.state.currRow][this.state.currCol];\n            prevFinishNode.isFinish = false;\n            document.getElementById(`node-${this.state.currRow}-${this.state.currCol}`).className = 'node';\n            this.setState({\n              currRow: row,\n              currCol: col\n            });\n            const currFinishNode = this.state.grid[row][col];\n            currFinishNode.isFinish = true;\n            document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\n          }\n          this.setState({\n            FINISH_NODE_ROW: row,\n            FINISH_NODE_COL: col\n          });\n        } else if (this.state.isWallNode) {\n          const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n          this.setState({\n            grid: newGrid\n          });\n        }\n      }\n    }\n  }\n  handleMouseUp(row, col) {\n    if (!this.state.isRunning) {\n      this.setState({\n        mouseIsPressed: false\n      });\n      if (this.state.isStartNode) {\n        const isStartNode = !this.state.isStartNode;\n        this.setState({\n          isStartNode,\n          START_NODE_ROW: row,\n          START_NODE_COL: col\n        });\n      } else if (this.state.isFinishNode) {\n        const isFinishNode = !this.state.isFinishNode;\n        this.setState({\n          isFinishNode,\n          FINISH_NODE_ROW: row,\n          FINISH_NODE_COL: col\n        });\n      }\n      this.getInitialGrid();\n    }\n  }\n  handleMouseLeave() {\n    if (this.state.isStartNode) {\n      const isStartNode = !this.state.isStartNode;\n      this.setState({\n        isStartNode,\n        mouseIsPressed: false\n      });\n    } else if (this.state.isFinishNode) {\n      const isFinishNode = !this.state.isFinishNode;\n      this.setState({\n        isFinishNode,\n        mouseIsPressed: false\n      });\n    } else if (this.state.isWallNode) {\n      const isWallNode = !this.state.isWallNode;\n      this.setState({\n        isWallNode,\n        mouseIsPressed: false\n      });\n      this.getInitialGrid();\n    }\n  }\n\n  /******************** Clear Board/Walls ********************/\n\n  clearGrid() {\n    if (!this.state.isRunning) {\n      const newGrid = this.state.grid.slice();\n      for (const row of newGrid) {\n        for (const node of row) {\n          let nodeClassName = document.getElementById(`node-${node.row}-${node.col}`).className;\n          if (nodeClassName !== 'node node-start' && nodeClassName !== 'node node-finish' && nodeClassName !== 'node node-wall') {\n            document.getElementById(`node-${node.row}-${node.col}`).className = 'node';\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.distanceToFinishNode = Math.abs(this.state.FINISH_NODE_ROW - node.row) + Math.abs(this.state.FINISH_NODE_COL - node.col);\n          }\n          if (nodeClassName === 'node node-finish') {\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.distanceToFinishNode = 0;\n          }\n          if (nodeClassName === 'node node-start') {\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.distanceToFinishNode = Math.abs(this.state.FINISH_NODE_ROW - node.row) + Math.abs(this.state.FINISH_NODE_COL - node.col);\n            node.isStart = true;\n            node.isWall = false;\n            node.previousNode = null;\n            node.isNode = true;\n          }\n        }\n      }\n    }\n  }\n  clearWalls() {\n    if (!this.state.isRunning) {\n      const newGrid = this.state.grid.slice();\n      for (const row of newGrid) {\n        for (const node of row) {\n          let nodeClassName = document.getElementById(`node-${node.row}-${node.col}`).className;\n          if (nodeClassName === 'node node-wall') {\n            document.getElementById(`node-${node.row}-${node.col}`).className = 'node';\n            node.isWall = false;\n          }\n        }\n      }\n    }\n  }\n\n  /******************** Create Animations ********************/\n  visualize(algo) {\n    if (!this.state.isRunning) {\n      this.clearGrid();\n      this.toggleIsRunning();\n      const {\n        grid\n      } = this.state;\n      const startNode = grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\n      const finishNode = grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\n      let visitedNodesInOrder;\n      switch (algo) {\n        case 'Dijkstra':\n          visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n          break;\n        case 'AStar':\n          visitedNodesInOrder = AStar(grid, startNode, finishNode);\n          break;\n        case 'BFS':\n          visitedNodesInOrder = bfs(grid, startNode, finishNode);\n          break;\n        case 'DFS':\n          visitedNodesInOrder = dfs(grid, startNode, finishNode);\n          break;\n        default:\n          // should never get here\n          break;\n      }\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n      nodesInShortestPathOrder.push('end');\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\n    }\n  }\n  animate(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        const nodeClassName = document.getElementById(`node-${node.row}-${node.col}`).className;\n        if (nodeClassName !== 'node node-start' && nodeClassName !== 'node node-finish') {\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\n        }\n      }, 10 * i);\n    }\n  }\n\n  /******************** Create path from start to finish ********************/\n  animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      if (nodesInShortestPathOrder[i] === 'end') {\n        setTimeout(() => {\n          this.toggleIsRunning();\n        }, i * 50);\n      } else {\n        setTimeout(() => {\n          const node = nodesInShortestPathOrder[i];\n          const nodeClassName = document.getElementById(`node-${node.row}-${node.col}`).className;\n          if (nodeClassName !== 'node node-start' && nodeClassName !== 'node node-finish') {\n            document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path';\n          }\n        }, i * 40);\n      }\n    }\n  }\n  render() {\n    const {\n      grid,\n      mouseIsPressed\n    } = this.state;\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"app-container\",\n      children: [/*#__PURE__*/_jsxDEV(\"nav\", {\n        className: \"navbar navbar-dark bg-dark justify-content-center\",\n        children: /*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"navbar-brand mb-0 h1 text-center\",\n          children: /*#__PURE__*/_jsxDEV(\"strong\", {\n            children: \" Path Visualizer\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 367,\n            columnNumber: 11\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 366,\n          columnNumber: 9\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 365,\n        columnNumber: 7\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"main-content\",\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"grid-wrapper\",\n          children: /*#__PURE__*/_jsxDEV(\"table\", {\n            className: \"grid-container\",\n            onMouseLeave: () => this.handleMouseLeave(),\n            children: /*#__PURE__*/_jsxDEV(\"tbody\", {\n              className: \"grid\",\n              children: grid.map((row, rowIdx) => {\n                return /*#__PURE__*/_jsxDEV(\"tr\", {\n                  children: row.map((node, nodeIdx) => {\n                    const {\n                      row,\n                      col,\n                      isFinish,\n                      isStart,\n                      isWall\n                    } = node;\n                    return /*#__PURE__*/_jsxDEV(Node, {\n                      col: col,\n                      isFinish: isFinish,\n                      isStart: isStart,\n                      isWall: isWall,\n                      mouseIsPressed: mouseIsPressed,\n                      onMouseDown: (row, col) => this.handleMouseDown(row, col),\n                      onMouseEnter: (row, col) => this.handleMouseEnter(row, col),\n                      onMouseUp: () => this.handleMouseUp(row, col),\n                      row: row\n                    }, nodeIdx, false, {\n                      fileName: _jsxFileName,\n                      lineNumber: 383,\n                      columnNumber: 25\n                    }, this);\n                  })\n                }, rowIdx, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 379,\n                  columnNumber: 19\n                }, this);\n              })\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 376,\n              columnNumber: 13\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 373,\n            columnNumber: 11\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 372,\n          columnNumber: 9\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"controls\",\n          children: [/*#__PURE__*/_jsxDEV(\"button\", {\n            type: \"button\",\n            className: \"btn btn-danger mb-2\",\n            onClick: () => this.clearGrid(),\n            children: \"Clear Grid\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 409,\n            columnNumber: 11\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            type: \"button\",\n            className: \"btn btn-warning mb-2\",\n            onClick: () => this.clearWalls(),\n            children: \"Clear Walls\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 415,\n            columnNumber: 11\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            type: \"button\",\n            className: \"btn btn-primary mb-2\",\n            onClick: () => this.visualize('Dijkstra'),\n            children: \"Dijkstra's\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 421,\n            columnNumber: 11\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            type: \"button\",\n            className: \"btn btn-primary mb-2\",\n            onClick: () => this.visualize('AStar'),\n            children: \"A*\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 427,\n            columnNumber: 11\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            type: \"button\",\n            className: \"btn btn-primary mb-2\",\n            onClick: () => this.visualize('BFS'),\n            children: \"Breadth First Search\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 433,\n            columnNumber: 11\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            type: \"button\",\n            className: \"btn btn-primary mb-2\",\n            onClick: () => this.visualize('DFS'),\n            children: \"Depth First Search\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 439,\n            columnNumber: 11\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 408,\n          columnNumber: 9\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 371,\n        columnNumber: 7\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 364,\n      columnNumber: 5\n    }, this);\n  }\n}\n\n/******************** Create Walls ********************/\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  // mouseDown starts to act strange if I don't make newGrid and work off of grid instead.\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  if (!node.isStart && !node.isFinish && node.isNode) {\n    const newNode = {\n      ...node,\n      isWall: !node.isWall\n    };\n    newGrid[row][col] = newNode;\n  }\n  return newGrid;\n};\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called after the pathfinding methods.\nfunction getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"names":["React","Component","Node","dijkstra","AStar","dfs","bfs","jsxDEV","_jsxDEV","PathfindingVisualizer","constructor","getInitialGrid","rowCount","state","ROW_COUNT","colCount","COLUMN_COUNT","initialGrid","row","currentRow","col","push","createNode","isStart","START_NODE_ROW","START_NODE_COL","isFinish","FINISH_NODE_ROW","FINISH_NODE_COL","distance","Infinity","distanceToFinishNode","Math","abs","isVisited","isWall","previousNode","isNode","grid","mouseIsPressed","isRunning","isStartNode","isFinishNode","isWallNode","currRow","currCol","handleMouseDown","bind","handleMouseLeave","toggleIsRunning","componentDidMount","setState","isGridClear","document","getElementById","className","newGrid","getNewGridWithWallToggled","clearGrid","node","nodeClassName","handleMouseEnter","prevStartNode","currStartNode","prevFinishNode","currFinishNode","handleMouseUp","slice","clearWalls","visualize","algo","startNode","finishNode","visitedNodesInOrder","nodesInShortestPathOrder","getNodesInShortestPathOrder","animate","i","length","setTimeout","animateShortestPath","render","children","fileName","_jsxFileName","lineNumber","columnNumber","onMouseLeave","map","rowIdx","nodeIdx","onMouseDown","onMouseEnter","onMouseUp","type","onClick","newNode","currentNode","unshift"],"sources":["C:/Users/TARUN/Downloads/pathFinderVisualizer-master/pathFinderVisualizer-master/src/PathfindingVisualizer/PathfindingVisualizer.jsx"],"sourcesContent":["import React, {Component} from 'react';\r\nimport Node from './Node/Node';\r\nimport {dijkstra} from '../algorithms/dijkstra';\r\nimport {AStar} from '../algorithms/aStar';\r\nimport {dfs} from '../algorithms/dfs';\r\nimport {bfs} from '../algorithms/bfs';\r\n\r\nimport './PathfindingVisualizer.css';\r\n\r\nexport default class PathfindingVisualizer extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      grid: [],\r\n      START_NODE_ROW: 3,\r\n      FINISH_NODE_ROW: 16,\r\n      START_NODE_COL: 5,\r\n      FINISH_NODE_COL: 25,\r\n      mouseIsPressed: false,\r\n      ROW_COUNT: 25,\r\n      COLUMN_COUNT: 35,\r\n      isRunning: false,\r\n      isStartNode: false,\r\n      isFinishNode: false,\r\n      isWallNode: false, // xxxxxxx\r\n      currRow: 0,\r\n      currCol: 0,\r\n    };\r\n\r\n    this.handleMouseDown = this.handleMouseDown.bind(this);\r\n    this.handleMouseLeave = this.handleMouseLeave.bind(this);\r\n    this.toggleIsRunning = this.toggleIsRunning.bind(this);\r\n  }\r\n\r\n  componentDidMount() {\r\n    const grid = this.getInitialGrid();\r\n    this.setState({grid});\r\n  }\r\n\r\n  toggleIsRunning() {\r\n    this.setState({isRunning: !this.state.isRunning});\r\n  }\r\n\r\n  /******************** Set up the initial grid ********************/\r\n  getInitialGrid = (\r\n    rowCount = this.state.ROW_COUNT,\r\n    colCount = this.state.COLUMN_COUNT,\r\n  ) => {\r\n    const initialGrid = [];\r\n    for (let row = 0; row < rowCount; row++) {\r\n      const currentRow = [];\r\n      for (let col = 0; col < colCount; col++) {\r\n        currentRow.push(this.createNode(row, col));\r\n      }\r\n      initialGrid.push(currentRow);\r\n    }\r\n    return initialGrid;\r\n  };\r\n\r\n  createNode = (row, col) => {\r\n    return {\r\n      row,\r\n      col,\r\n      isStart:\r\n        row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL,\r\n      isFinish:\r\n        row === this.state.FINISH_NODE_ROW &&\r\n        col === this.state.FINISH_NODE_COL,\r\n      distance: Infinity,\r\n      distanceToFinishNode:\r\n        Math.abs(this.state.FINISH_NODE_ROW - row) +\r\n        Math.abs(this.state.FINISH_NODE_COL - col),\r\n      isVisited: false,\r\n      isWall: false,\r\n      previousNode: null,\r\n      isNode: true,\r\n    };\r\n  };\r\n\r\n  /******************** Control mouse events ********************/\r\n  handleMouseDown(row, col) {\r\n    if (!this.state.isRunning) {\r\n      if (this.isGridClear()) {\r\n        if (\r\n          document.getElementById(`node-${row}-${col}`).className ===\r\n          'node node-start'\r\n        ) {\r\n          this.setState({\r\n            mouseIsPressed: true,\r\n            isStartNode: true,\r\n            currRow: row,\r\n            currCol: col,\r\n          });\r\n        } else if (\r\n          document.getElementById(`node-${row}-${col}`).className ===\r\n          'node node-finish'\r\n        ) {\r\n          this.setState({\r\n            mouseIsPressed: true,\r\n            isFinishNode: true,\r\n            currRow: row,\r\n            currCol: col,\r\n          });\r\n        } else {\r\n          const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n          this.setState({\r\n            grid: newGrid,\r\n            mouseIsPressed: true,\r\n            isWallNode: true,\r\n            currRow: row,\r\n            currCol: col,\r\n          });\r\n        }\r\n      } else {\r\n        this.clearGrid();\r\n      }\r\n    }\r\n  }\r\n\r\n  isGridClear() {\r\n    for (const row of this.state.grid) {\r\n      for (const node of row) {\r\n        const nodeClassName = document.getElementById(\r\n          `node-${node.row}-${node.col}`,\r\n        ).className;\r\n        if (\r\n          nodeClassName === 'node node-visited' ||\r\n          nodeClassName === 'node node-shortest-path'\r\n        ) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.isRunning) {\r\n      if (this.state.mouseIsPressed) {\r\n        const nodeClassName = document.getElementById(`node-${row}-${col}`)\r\n          .className;\r\n        if (this.state.isStartNode) {\r\n          if (nodeClassName !== 'node node-wall') {\r\n            const prevStartNode = this.state.grid[this.state.currRow][\r\n              this.state.currCol\r\n            ];\r\n            prevStartNode.isStart = false;\r\n            document.getElementById(\r\n              `node-${this.state.currRow}-${this.state.currCol}`,\r\n            ).className = 'node';\r\n\r\n            this.setState({currRow: row, currCol: col});\r\n            const currStartNode = this.state.grid[row][col];\r\n            currStartNode.isStart = true;\r\n            document.getElementById(`node-${row}-${col}`).className =\r\n              'node node-start';\r\n          }\r\n          this.setState({START_NODE_ROW: row, START_NODE_COL: col});\r\n        } else if (this.state.isFinishNode) {\r\n          if (nodeClassName !== 'node node-wall') {\r\n            const prevFinishNode = this.state.grid[this.state.currRow][\r\n              this.state.currCol\r\n            ];\r\n            prevFinishNode.isFinish = false;\r\n            document.getElementById(\r\n              `node-${this.state.currRow}-${this.state.currCol}`,\r\n            ).className = 'node';\r\n\r\n            this.setState({currRow: row, currCol: col});\r\n            const currFinishNode = this.state.grid[row][col];\r\n            currFinishNode.isFinish = true;\r\n            document.getElementById(`node-${row}-${col}`).className =\r\n              'node node-finish';\r\n          }\r\n          this.setState({FINISH_NODE_ROW: row, FINISH_NODE_COL: col});\r\n        } else if (this.state.isWallNode) {\r\n          const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n          this.setState({grid: newGrid});\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  handleMouseUp(row, col) {\r\n    if (!this.state.isRunning) {\r\n      this.setState({mouseIsPressed: false});\r\n      if (this.state.isStartNode) {\r\n        const isStartNode = !this.state.isStartNode;\r\n        this.setState({isStartNode, START_NODE_ROW: row, START_NODE_COL: col});\r\n      } else if (this.state.isFinishNode) {\r\n        const isFinishNode = !this.state.isFinishNode;\r\n        this.setState({\r\n          isFinishNode,\r\n          FINISH_NODE_ROW: row,\r\n          FINISH_NODE_COL: col,\r\n        });\r\n      }\r\n      this.getInitialGrid();\r\n    }\r\n  }\r\n\r\n  handleMouseLeave() {\r\n    if (this.state.isStartNode) {\r\n      const isStartNode = !this.state.isStartNode;\r\n      this.setState({isStartNode, mouseIsPressed: false});\r\n    } else if (this.state.isFinishNode) {\r\n      const isFinishNode = !this.state.isFinishNode;\r\n      this.setState({isFinishNode, mouseIsPressed: false});\r\n    } else if (this.state.isWallNode) {\r\n      const isWallNode = !this.state.isWallNode;\r\n      this.setState({isWallNode, mouseIsPressed: false});\r\n      this.getInitialGrid();\r\n    }\r\n  }\r\n\r\n  /******************** Clear Board/Walls ********************/\r\n\r\n  clearGrid() {\r\n    if (!this.state.isRunning) {\r\n      const newGrid = this.state.grid.slice();\r\n      for (const row of newGrid) {\r\n        for (const node of row) {\r\n          let nodeClassName = document.getElementById(\r\n            `node-${node.row}-${node.col}`,\r\n          ).className;\r\n          if (\r\n            nodeClassName !== 'node node-start' &&\r\n            nodeClassName !== 'node node-finish' &&\r\n            nodeClassName !== 'node node-wall'\r\n          ) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              'node';\r\n            node.isVisited = false;\r\n            node.distance = Infinity;\r\n            node.distanceToFinishNode =\r\n              Math.abs(this.state.FINISH_NODE_ROW - node.row) +\r\n              Math.abs(this.state.FINISH_NODE_COL - node.col);\r\n          }\r\n          if (nodeClassName === 'node node-finish') {\r\n            node.isVisited = false;\r\n            node.distance = Infinity;\r\n            node.distanceToFinishNode = 0;\r\n          }\r\n          if (nodeClassName === 'node node-start') {\r\n            node.isVisited = false;\r\n            node.distance = Infinity;\r\n            node.distanceToFinishNode =\r\n              Math.abs(this.state.FINISH_NODE_ROW - node.row) +\r\n              Math.abs(this.state.FINISH_NODE_COL - node.col);\r\n            node.isStart = true;\r\n            node.isWall = false;\r\n            node.previousNode = null;\r\n            node.isNode = true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  clearWalls() {\r\n    if (!this.state.isRunning) {\r\n      const newGrid = this.state.grid.slice();\r\n      for (const row of newGrid) {\r\n        for (const node of row) {\r\n          let nodeClassName = document.getElementById(\r\n            `node-${node.row}-${node.col}`,\r\n          ).className;\r\n          if (nodeClassName === 'node node-wall') {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              'node';\r\n            node.isWall = false;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /******************** Create Animations ********************/\r\n  visualize(algo) {\r\n    if (!this.state.isRunning) {\r\n      this.clearGrid();\r\n      this.toggleIsRunning();\r\n      const {grid} = this.state;\r\n      const startNode =\r\n        grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n      const finishNode =\r\n        grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\r\n      let visitedNodesInOrder;\r\n      switch (algo) {\r\n        case 'Dijkstra':\r\n          visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n          break;\r\n        case 'AStar':\r\n          visitedNodesInOrder = AStar(grid, startNode, finishNode);\r\n          break;\r\n        case 'BFS':\r\n          visitedNodesInOrder = bfs(grid, startNode, finishNode);\r\n          break;\r\n        case 'DFS':\r\n          visitedNodesInOrder = dfs(grid, startNode, finishNode);\r\n          break;\r\n        default:\r\n          // should never get here\r\n          break;\r\n      }\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n      nodesInShortestPathOrder.push('end');\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    }\r\n  }\r\n\r\n  animate(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, 10 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        const nodeClassName = document.getElementById(\r\n          `node-${node.row}-${node.col}`,\r\n        ).className;\r\n        if (\r\n          nodeClassName !== 'node node-start' &&\r\n          nodeClassName !== 'node node-finish'\r\n        ) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            'node node-visited';\r\n        }\r\n      }, 10 * i);\r\n    }\r\n  }\r\n\r\n  /******************** Create path from start to finish ********************/\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      if (nodesInShortestPathOrder[i] === 'end') {\r\n        setTimeout(() => {\r\n          this.toggleIsRunning();\r\n        }, i * 50);\r\n      } else {\r\n        setTimeout(() => {\r\n          const node = nodesInShortestPathOrder[i];\r\n          const nodeClassName = document.getElementById(\r\n            `node-${node.row}-${node.col}`,\r\n          ).className;\r\n          if (\r\n            nodeClassName !== 'node node-start' &&\r\n            nodeClassName !== 'node node-finish'\r\n          ) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              'node node-shortest-path';\r\n          }\r\n        }, i * 40);\r\n      }\r\n    }\r\n  }\r\n\r\n render() {\r\n  const {grid, mouseIsPressed} = this.state;\r\n  return (\r\n    <div className=\"app-container\">\r\n      <nav className=\"navbar navbar-dark bg-dark justify-content-center\">\r\n        <span className=\"navbar-brand mb-0 h1 text-center\">\r\n          <strong> Path Visualizer</strong>\r\n        </span>\r\n      </nav>\r\n\r\n      <div className=\"main-content\">\r\n        <div className=\"grid-wrapper\">\r\n          <table\r\n            className=\"grid-container\"\r\n            onMouseLeave={() => this.handleMouseLeave()}>\r\n            <tbody className=\"grid\">\r\n              {grid.map((row, rowIdx) => {\r\n                return (\r\n                  <tr key={rowIdx}>\r\n                    {row.map((node, nodeIdx) => {\r\n                      const {row, col, isFinish, isStart, isWall} = node;\r\n                      return (\r\n                        <Node\r\n                          key={nodeIdx}\r\n                          col={col}\r\n                          isFinish={isFinish}\r\n                          isStart={isStart}\r\n                          isWall={isWall}\r\n                          mouseIsPressed={mouseIsPressed}\r\n                          onMouseDown={(row, col) =>\r\n                            this.handleMouseDown(row, col)\r\n                          }\r\n                          onMouseEnter={(row, col) =>\r\n                            this.handleMouseEnter(row, col)\r\n                          }\r\n                          onMouseUp={() => this.handleMouseUp(row, col)}\r\n                          row={row}\r\n                        ></Node>\r\n                      );\r\n                    })}\r\n                  </tr>\r\n                );\r\n              })}\r\n            </tbody>\r\n          </table>\r\n        </div>\r\n\r\n        <div className=\"controls\">\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-danger mb-2\"\r\n            onClick={() => this.clearGrid()}>\r\n            Clear Grid\r\n          </button>\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-warning mb-2\"\r\n            onClick={() => this.clearWalls()}>\r\n            Clear Walls\r\n          </button>\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-primary mb-2\"\r\n            onClick={() => this.visualize('Dijkstra')}>\r\n            Dijkstra's\r\n          </button>\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-primary mb-2\"\r\n            onClick={() => this.visualize('AStar')}>\r\n            A*\r\n          </button>\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-primary mb-2\"\r\n            onClick={() => this.visualize('BFS')}>\r\n            Breadth First Search\r\n          </button>\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-primary mb-2\"\r\n            onClick={() => this.visualize('DFS')}>\r\n            Depth First Search\r\n          </button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n}\r\n\r\n/******************** Create Walls ********************/\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  // mouseDown starts to act strange if I don't make newGrid and work off of grid instead.\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  if (!node.isStart && !node.isFinish && node.isNode) {\r\n    const newNode = {\r\n      ...node,\r\n      isWall: !node.isWall,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n  }\r\n  return newGrid;\r\n};\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called after the pathfinding methods.\r\nfunction getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}